# 373. Find K Pairs with Smallest Sums — итоги разбора

Задача: даны два неубывающих массива `nums1`, `nums2` и число `k`. Вернуть `k` пар `(u, v)` (u из nums1, v из nums2) с наименьшими суммами `u + v`.

Решение: мин-куча кандидатов — пары индексов `(i, j)`. Старт с `(0, 0)`. При извлечении `(i, j)` в кучу добавляются соседи `(i, j+1)` и `(i+1, j)`; дубликаты отсекаются через `Set` посещённых пар (или альтернатива без visited — см. ниже).

---

## 1. Сложность

- **Время:** O(k log k).  
  Не более k извлечений и порядка 2k добавлений в кучу; размер кучи O(k), каждая операция O(log k).

- **Память:** O(k).  
  Куча O(k) узлов; при варианте с visited — Set с O(k) ключей (строки `"i,j"`).

---

## 2. Альтернатива без visited

**Идея:** в кучу добавлять только одного «соседа» — шаг вправо: из `(i, j)` кладём только `(i, j+1)`. Тогда каждая пара `(i, j)` попадает в кучу не более одного раза (когда извлекли `(i, j-1)`), дубликатов нет.

**Старт:** в кучу положить по одному кандидату на каждую строку — пары `(i, 0)` для `i = 0 .. min(k, nums1.length) - 1` с суммой `nums1[i] + nums2[0]`.

**Цикл:** пока не набрали k пар и куча не пуста — извлечь минимум `(i, j)`, добавить в ответ `[nums1[i], nums2[j]]`, при `j + 1 < nums2.length` добавить в кучу `(i, j+1)`.

**Плюсы:** нет Set, меньше кода и памяти. **Минусы:** начальная куча размера до min(k, n) вместо одного элемента. Асимптотика та же — O(k log k) по времени, O(k) по памяти.

---

## 3. Краевые случаи

- **Пустые массивы / k ≤ 0:** в условии LeetCode длины ≥ 1 и k ≥ 1; для устойчивости в начале функции можно добавить `if (!nums1.length || !nums2.length || k <= 0) return []`.
- **k больше числа пар:** пар всего `nums1.length * nums2.length`. Цикл выходит по условию `minheap.size && res.length < k` — как только куча пуста. Возвращаем все существующие пары (меньше k), что корректно.
- **Один элемент в массивах:** `nums1 = [a], nums2 = [b]`, k любое — в кучу попадёт только (0,0), после извлечения соседей нет, возвращается одна пара.
- **Одинаковые суммы:** порядок пар с равной суммой задаётся сравнением в куче (по sum, затем по i, затем по j) — результат детерминирован.
