# 2462. Total Cost to Hire K Workers — итоги разбора

Задача: нанять k работников. На каждом шаге рассматриваются первые `candidates` и последние `candidates` из оставшихся; выбирается работник с минимальной стоимостью (при равенстве — с меньшим индексом). Вернуть сумму затрат.

Решение: две мин-кучи (левое и правое «окно»), указатели `l` и `r` сужаются к центру; при выборе минимума из вершин куч подтягивается следующий элемент с границы.

---

## 1. Сложность

Обозначения: **n** — длина `costs`, **k** — число нанимаемых, **c** — `candidates`.

- **Время:** O((c + k) log c).  
  Инициализация: заполнение двух куч по c элементов — O(c log c). Основной цикл: k итераций, на каждой 2 peek O(1), 1 poll и до 1 add — O(log c). Размер каждой кучи не превосходит c. Итого O(c log c + k log c).

- **Память:** O(c).  
  Две кучи размера O(c), плюс O(1) под индексы и сумму.

---

## 2. Альтернативы

| Подход | Идея | Плюсы | Минусы |
|--------|------|--------|--------|
| **Две кучи (текущее)** | Левое и правое окно по c кандидатов, минимум из двух вершин | O(k log c), не трогаем середину массива | Нужна аккуратная инициализация при перекрытии окон (l ≤ r) и корректный tie-break (слева при равном cost) |
| **Одна куча с парами (cost, index)** | Кладить в кучу все «активные» индексы с cost, сравнивать по cost, при равенстве по index | Одна структура, проще мысленная модель | Размер кучи может расти (все непройденные граничные индексы), сложность и память выше |
| **Сортировка «кандидатов» на каждом шаге** | Каждый раз брать первые и последние c элементов, сортировать, брать минимум | Реализация без своей кучи | O(k · c log c) — при больших k и c хуже, чем кучи |
| **Два указателя + линейный поиск минимума в окнах** | На каждом шаге проходить по левым и правым c элементам, искать минимум | O(1) дополнительной памяти (если не считать сам массив) | O(k · c) по времени — приемлемо только при малом c |

Вывод: для ограничений задачи две кучи дают оптимальный по времени баланс при произвольных k и c.

---

## 3. Оптимизация и исправления

- **Инициализация правой кучи:** изначально стояло условие `l < r` при добавлении в minR. При `l === r` элемент по индексу на границе (например, единственный «средний») не попадал ни в одну кучу. Исправлено на `l <= r`, чтобы все последние c позиций, не пересекающиеся с левым окном, попадали в правую кучу.

- **Выбор «левая vs правая» куча:** условие должно давать «берём слева, если правой нет ИЛИ (левая есть и cost слева ≤ справа)» — при равенстве cost по условию берётся меньший индекс (слева). Было ошибочно `(!minL.size() && leftPeek <= rightPeek)`, из-за чего при двух непустых кучах всегда брали из правой. Исправлено на `(minL.size() && leftPeek <= rightPeek)`.

- **Переиспользование кучи:** класс MinHeap можно вынести в общий модуль и использовать в других задачах (например, 373, 2542), чтобы не дублировать код.

---

## 4. Краевые случаи

- **Перекрытие окон:** при `2 * candidates > n` левое и правое окна пересекаются. Инициализация с `l <= r` гарантирует, что каждый индекс попадёт не более чем в одну кучу (сначала заполняется левая до l, затем правая с r вниз, пока `l <= r`).
- **k = 1:** достаточно одного выбора минимума из двух куч после инициализации.
- **k = n:** нанимаем всех; кучи опустошаются, подтягиваются все элементы с границ до схождения l и r.
- **n = 1, candidates = 1:** одна куча с одним элементом, вторая пустая — корректно обрабатывается условием `!minR.size() || (minL.size() && leftPeek <= rightPeek)`.
- **Одинаковые cost:** tie-break по индексу обеспечивается выбором левой кучи при `leftPeek <= rightPeek`.
