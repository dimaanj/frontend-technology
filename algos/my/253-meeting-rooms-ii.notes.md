# 253. Meeting Rooms II — итоги разбора

## Условие (кратко)

Дан массив интервалов `[start_i, end_i]`. Найти минимальное количество конференц-залов, необходимое для проведения всех встреч без пересечений. Интервалы впритык (`[0,5]` и `[5,10]`) могут использовать одну комнату.

## Подход к решению

**Идея:** использовать min-heap для хранения времени окончания занятых комнат. При обработке каждого интервала:
- Если самая ранняя освобождающаяся комната освободилась до начала текущей встречи (`current[0] >= minEnd`) — переиспользовать эту комнату (удалить из heap, добавить новый конец).
- Иначе — нужна новая комната (добавить конец текущей встречи в heap).

Размер heap в конце — это количество необходимых комнат.

**Альтернатива — sweep line:** отсортировать все события (start/end) по времени, проходить по ним и считать баланс: при start +1, при end -1. Максимальный баланс — ответ. Время O(n log n), память O(n) на события.

## Текущее решение (требует доработки)

Используется самописный MinHeap. Проблемы, обнаруженные при тестировании:

1. **Сортировка:** `intervals.sort()` без компаратора сортирует как строки, а не по `start`. Нужно: `intervals.sort((a, b) => a[0] - b[0])`.

2. **Типы данных в heap:** в heap должны храниться только **концы интервалов** (числа), а не сами интервалы. Сейчас: `minheap.add(intervals[0])` добавляет массив, а потом `minheap.add(current[1])` — число. Нужна консистентность: только `end` значения.

3. **Пустой массив:** перед добавлением в heap нужно проверить `if (intervals.length === 0) return 0;`, иначе обращение к `intervals[0]` даст `undefined`.

4. **Логика сравнения:** проверка `current[0] > minheap.peek()` сравнивает start с end (или с массивом, если тип неверный). Правильно: `current[0] >= minheap.peek()` (если текущий start >= самого раннего конца — комната освободилась, можно переиспользовать).

5. **Инициализация:** первый интервал добавляется в heap до цикла, но его конец должен быть `intervals[0][1]`, а не весь `intervals[0]`.

## Правильный алгоритм

```javascript
intervals.sort((a, b) => a[0] - b[0]);
if (intervals.length === 0) return 0;

const minHeap = new MinHeap();
minHeap.add(intervals[0][1]); // добавляем конец первого интервала

for (let i = 1; i < intervals.length; i++) {
  const [start, end] = intervals[i];
  if (start >= minHeap.peek()) {
    minHeap.poll(); // освобождаем комнату
  }
  minHeap.add(end); // занимаем комнату (новую или освободившуюся)
}

return minHeap.size();
```

## Сложность

- **Время:** O(n log n) — сортировка O(n log n); цикл O(n), каждая операция heap (add/poll) O(log n), итого O(n log n).
- **Память:** O(n) — в худшем случае все интервалы пересекаются, heap содержит n элементов.

## Альтернативы

- **Sweep line:** O(n log n) время, O(n) память. Может быть проще в реализации (не нужен heap), но требует сортировки всех событий.
- **Сортировка + два указателя:** отсортировать starts и ends отдельно, проходить по обоим массивам, считать баланс. Та же сложность, но без heap.

## Краевые случаи

- Пустой массив → 0.
- Одно совещание → 1.
- Два впритык `[0,5],[5,10]` → 1 (конец первого = начало второго, одна комната).
- Цепочка без пересечений → 1.
- Все начинаются в одной точке → количество интервалов.
- Интервалы нулевой длины `[1,1],[1,1]` → 2 (одновременные события требуют разные комнаты).
