# 642. Design Search Autocomplete System — итоги разбора

Задача: автодополнение по префиксу, топ-3 по частоте (при равенстве — лексикографически). Ввод по символам, `#` — конец фразы.

---

## 1. Сложность

Обозначения: **P** — длина префикса при запросе, **L** — длина предложения при добавлении, **M** — число предложений с данным префиксом, **N** — размер поддерева (узлов) от узла префикса, **n** — число уникальных предложений в системе.

### Вариант A (Trie + в узле Map «предложение → частота»)

- **Добавление (input '#'):** O(L) — проход по символам, в каждом узле обновление Map.
- **Запрос подсказок:** O(P + M) — спуск по префиксу O(P), обход M кандидатов и heap размера 3.
- **Память:** O(n·L) — каждое предложение хранится в L узлах.

### Вариант B (в узле только «конец слова», при запросе DFS)

- **Добавление:** O(L).
- **Запрос:** O(P + N) при использовании heap размера 3; O(P + N + M log M) при сборе всех концов слов и полной сортировке. N — число узлов в поддереве (связано с «оставшимися» символами в путях).
- **Память:** O(n·L) — только узлы Trie и в листьях строка + счётчик (без дублирования предложений во многих узлах, как в A).

Уточнение по формуле «P + n·log s»: корректнее **P + N + M** (с heap) или **P + N + M log M** (с сортировкой). Множитель n·log s не получается из обхода поддерева и операций с топ-3.

### Вариант C (в узле кэш топ-3)

- **Добавление:** O(L·M') в худшем случае — на каждом из L узлов пересчёт топ-3 из до M' предложений (сортировка или heap).
- **Запрос:** O(P) — спуск по префиксу и чтение готового топ-3.
- **Память:** O(n·L) плюс константа на узел для топ-3.

---

## 2. Альтернативы

| Вариант | Идея | Плюсы | Минусы |
|--------|------|--------|--------|
| **A** | В каждом узле Map «предложение → частота» по префиксу | Простая логика, быстрый запрос O(P+M), добавление O(L) | Больше памяти: предложения дублируются по узлам |
| **B** | В узле только конец слова (sentence + count), при запросе DFS по поддереву | Меньше дублирования строк в памяти | Запрос дороже: обход поддерева O(N), плюс сбор и сортировка/heap |
| **C** | В узле хранить готовый топ-3, при добавлении пересчитывать вдоль пути | Запрос O(P) | Добавление дорогое O(L·M') при большом числе предложений с префиксом |

Когда что выгоднее: A — универсальный баланс; B — когда важна экономия памяти при редких запросах; C — когда запросов очень много, а добавлений мало.

---

## 3. Оптимизация

- **Heap вместо полной сортировки для топ-3:** в A и B при выборе топ-3 использована min-heap размера 3. В корне — «худший» кандидат (меньшая частота, при равенстве — большая строка). Сложность на запрос остаётся O(P + M), но при больших M не делаем полную сортировку.
- **Куча не хранится в узле:** при попытке хранить heap в узле и обновлять его при каждом добавлении возникают дубликаты (одно предложение с разными счётчиками) и неверный топ-3. Кучу строят в момент запроса из актуального `node.counts`.
- **Компаратор для min-heap:** «минимальный» = худший кандидат: сначала по возрастанию count (cA - cB), при равенстве по убыванию строки (b[0].localeCompare(a[0])). После выемки из кучи результат разворачивают, чтобы вернуть порядок «лучший → худший».
- **Вариант C:** в `_updateTop3` можно заменить полную сортировку на heap размера 3, чтобы пересчёт топа был O(M') вместо O(M' log M').

---

## 4. Краевые случаи (edge cases)

- **Пустой текущий ввод и '#':** при `current === ""` и вводе `#` предложение не добавляется, возвращается `[]`.
- **Первый символ:** при пустом `current` после ввода первого символа нужно обновить `current` и вернуть подсказки по этому одному символу (не возвращать `[]`).
- **Меньше трёх совпадений:** возвращать все подходящие предложения (до 3).
- **Пустые начальные данные:** `sentences = []`, `times = []` — конструктор не падает; запросы возвращают `[]`.
- **Повтор одного и того же предложения:** при каждом `#` счётчик этого предложения увеличивается; порядок в подсказках должен учитывать новую частоту.
- **Один символ как фраза:** после ввода `"h"` и `#` фраза `"h"` сохраняется; при следующем запросе по префиксу `"h"` в подсказках могут быть и `"h"`, и другие (например, `"hello"`).

---

## 5. Ответы на дополнительные вопросы по реализации

- **Возвращаемое значение `input`:** при `c === '#'` — всегда `[]`; при обычном символе — массив до 3 строк (подсказки по текущему префиксу). В обеих ветках метод должен явно возвращать значение.
- **Обновление счётчика в варианте A:** в узле нужно брать текущее значение из Map: `(node.counts.get(sentence) || 0) + delta`, а не `(sentence || 0) + delta` (во втором случае записывалась бы строка или неверное число).
- **Порядок обновления в узле (A):** счётчик обновлять в узле **после** перехода в ребёнка, чтобы каждое предложение попадало в `counts` всех узлов вдоль своего префикса.
- **Сортировка топ-3:** сначала по убыванию частоты (cB - cA), при равенстве по возрастанию строки (a[0].localeCompare(b[0])).
- **Получение топ-3 из Map:** `node.counts.entries()` возвращает итератор; для сортировки нужен массив: `Array.from(node.counts.entries())`. Ограничение до 3 элементов — через `slice(0, 3)` или heap размера 3.
- **Вариант B, обход детей:** при итерации `for (const n of current.children)` у Map в `n` попадают пары `[ключ, значение]`. В стек нужно класть узлы — например, `for (const [, value] of current.children) stack.push(value)`.
- **Вариант B, дублирование в heap:** не добавлять текущий узел в heap до цикла и снова внутри цикла (первый `pop` даёт тот же узел) — либо добавлять только внутри цикла, либо не пушить стартовый узел в стек и обработать его отдельно один раз.
- **Опечатка в методе массива:** `reverse()` (не `reverese()`).
