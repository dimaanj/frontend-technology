# 2542. Maximum Subsequence Score — итоги разбора

## Условие (кратко)

Два массива `nums1`, `nums2` длины n, число k. Выбрать подпоследовательность из k индексов. Score = (сумма выбранных из nums1) × (минимум выбранных из nums2). Вернуть максимальный score.

## Подход к решению

**Идея:** сортировка пар `(nums1[i], nums2[i])` по `nums2` по убыванию. Для каждой позиции i фиксируем `nums2[i]` как минимум среди выбранных — тогда выбранные индексы лежат в [0..i], и набираем текущий элемент + (k−1) лучших по nums1 из [0..i−1]. Сумму этих (k−1) храним в min-куче размера k−1.

**Важный инвариант:** score считаем до добавления текущего элемента в кучу. Тогда набор всегда «текущий + (k−1) из кучи», минимум по nums2 в нём — текущий n2. После подсчёта добавляем текущий n1 в кучу; если размер > k−1, выталкиваем минимум и вычитаем его из суммы. Так вытолкнутым никогда не оказывается текущий элемент, и множитель n2 корректен.

**Подводный камень (вариант с кучей размера k):** если хранить в куче k элементов и после добавления текущего делать pop при size > k, вытолкнут может оказаться сам текущий элемент. Тогда в куче остаются k элементов только из [0..i−1], а в формуле используется n2 текущей строки — это неверно для этого набора. Либо считать score только когда текущий гарантированно в наборе, либо перейти к варианту «куча k−1 + текущий в формуле».

## Сложность

- **Время:** O(n log n) — сортировка O(n log n); цикл O(n), операции с кучей (push/pop) O(log k), итого O(n log n).
- **Память:** O(n) — пары и куча размера O(k) ≤ O(n).

## Альтернативы

- Перебор всех C(n,k) подпоследовательностей — O(n^k) или O(2^n), неприемлемо при n до 10^5.
- Сортировка + min-heap — принятый подход; без кучи при фиксированном минимуме пришлось бы каждый раз за O(k) или O(n) искать k−1 максимумов по nums1, что даёт O(n²) или O(nk).

## Оптимизация

- Куча хранит не более k−1 элементов; сумма хранится в переменной и обновляется при push/pop, без пересчёта по куче.
- Для k = 1 куча после каждого шага пустая (сразу pop), score = n1×n2 по каждому элементу — поведение корректно.

## Краевые случаи

- n = 1, k = 1 — один элемент, score = nums1[0]×nums2[0].
- k = n — берём всех; score = sum(nums1)×min(nums2).
- k = 1 — максимум по i от nums1[i]×nums2[i].
- Нули в nums2 — включение индекса с nums2[i]=0 даёт множитель 0; при k=1 выгодно взять другой индекс, если есть.
- Все nums2 равны — минимум фиксирован, максимизируем сумму k элементов из nums1 (куча даёт k−1 наибольших + текущий).
