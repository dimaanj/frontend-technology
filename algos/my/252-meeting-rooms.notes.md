# 252. Meeting Rooms — итоги разбора

## Условие (кратко)

Дан массив интервалов `[start_i, end_i]`. Вернуть `true`, если человек может посетить все встречи без пересечений. Два интервала пересекаются, если один начинается до того, как другой заканчивается (`current[0] < prev[1]` — пересечение).

## Решение

- Сортировка по `start`: `intervals.sort((a, b) => a[0] - b[0])`.
- Один проход: для каждого следующего интервала проверять `current[0] < prev[1]`. Если да — возврат `false`.
- Иначе по окончании цикла — `true`.

После сортировки достаточно сравнивать только соседние интервалы: если текущий старт меньше конца предыдущего, есть пересечение.

## Сложность

- **Время:** O(n log n) — даёт сортировка; цикл O(n).
- **Память:** O(1) по дополнительной памяти; сортировка в JS может использовать O(log n) под стек/внутренние структуры.

## Альтернатива — без сортировки

Проверка каждой пары интервалов: пересечение `[a,b]` и `[c,d]` — когда `a < d && c < b`. Два вложенных цикла → O(n²) по времени, O(1) по памяти. Имеет смысл только при очень маленьком n; при типичных ограничениях выгоднее O(n log n) с сортировкой.

## Краевые случаи

- Пустой массив: цикл не выполняется → `true`.
- Один интервал: цикл не выполняется → `true`.
- Два впритык `[0,10],[10,20]`: условие `10 < 10` ложно → пересечения нет, `true`.
- Интервалы нулевой длины `[1,1]`, `[1,1]`: та же логика — нет «строго до» → `true`.

## Замечание по мутации входа

`intervals.sort(...)` изменяет исходный массив. Если API требует неизменности входа, перед сортировкой делать копию, например `intervals.slice().sort(...)` — тогда память O(n).
