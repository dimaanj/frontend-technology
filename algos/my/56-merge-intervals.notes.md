# 56. Merge Intervals — итоги разбора

## Условие (кратко)

Дан массив интервалов `intervals[i] = [start_i, end_i]`. Объединить все перекрывающиеся интервалы и вернуть массив неперекрывающихся, покрывающих все входные. Перекрытие: интервалы впритык `[1,4]` и `[4,5]` тоже считаются перекрывающимися.

## Решение

- Сортировка по `start`: `intervals.sort((a, b) => a[0] - b[0])`.
- Один проход: в аккумуляторе последний интервал `merged[merged.length - 1]`. Если `current[0] <= prev[1]` — перекрытие, обновить конец: `prev[1] = Math.max(prev[1], current[1])`. Иначе — `merged.push(current)`.

Пустой массив обрабатывается в начале: `return []`.

## Сложность

- **Время:** O(n log n) — сортировка; цикл O(n).
- **Память:** O(n) на массив результата; сортировка in-place, но в JS может давать O(log n) под стек. Если не мутировать вход — копия `intervals` даёт +O(n).

## Альтернативы / упрощение

Условие слияния можно записать одной веткой: перекрытие — когда `current[0] <= prev[1]`, тогда всегда `prev[1] = Math.max(prev[1], current[1])`. Вариант с двумя условиями (`prev[1] <= current[1]` и т.д.) тоже корректен, но разветвлённее.

## Что поправляли при ревью

- Использовать последний элемент аккумулятора как `merged[merged.length - 1]`, а не `merged[i - 1]` (длины массивов не совпадают).
- При слиянии брать максимум концов: `Math.max(prev[1], current[1])`, иначе интервал, полностью лежащий внутри предыдущего, «сужал» результат.
- Не использовать `merged.pop()` без возврата элемента в массив — иначе накапливаемый результат терялся.

## Краевые случаи

- Пустой массив → `[]`.
- Один интервал → без изменений.
- Впритык `[1,4],[4,5]` → один `[1,5]`.
- Неотсортированный ввод — результат не зависит от порядка благодаря сортировке.
- Интервал внутри другого `[1,10],[2,5]` → `[1,10]`.
- Интервалы нулевой длины `[1,1],[1,1]` → `[1,1]`; `[1,1],[1,2]` → `[1,2]`.
