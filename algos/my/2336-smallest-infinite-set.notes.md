# SmallestInfiniteSet (LeetCode 2336) — варианты решений

## Основной вариант: Set + счётчик

- **Идея:** Бесконечный набор моделируем как «следующее не выданное» число `_next` и множество `_addedBack` — числа, которые уже вытащили и потом вернули через `addBack`.
- **popSmallest:** если `_addedBack` не пусто — вернуть минимум из него и удалить; иначе вернуть `_next` и увеличить его.
- **addBack(num):** если `num < _next`, добавить в `_addedBack` (чтобы не дублировать «бесконечный хвост», числа ≥ `_next` и так считаются в множестве).
- **Сложность:** по времени pop — O(k), где k = размер `_addedBack` (из‑за `Math.min(...set)`); addBack — O(1). По памяти O(k).
- **Плюсы:** просто, без доп. структур, не завязано на верхнюю границу 1000.

---

## Альтернатива 1: Min-heap для «вернувшихся» + счётчик

- **Идея:** Та же модель (бесконечность = `_next`), но множество «вернувшихся» храним в min-heap (и при необходимости в Set для проверки «уже в множестве» при `addBack`).
- **popSmallest:** если в куче есть элементы и минимум кучи < `_next` — извлечь минимум из кучи и вернуть; иначе вернуть `_next++`.
- **addBack(num):** если `num >= _next` или уже в множестве добавленных — не делать ничего; иначе добавить в кучу (и при необходимости в Set).
- **Сложность:** pop и addBack — O(log k), память O(k).
- **Плюсы:** быстрее при большом числе `addBack`; минус — нужна реализация кучи (в JS нет в стандартной библиотеке).

---

## Альтернатива 2: Одна min-heap на 1..1000 (по ограничениям)

- **Идея:** В условии `1 ≤ num ≤ 1000` и не более 1000 вызовов — значит, достаточно рассматривать только числа 1..1000. Храним min-heap из чисел, которые «сейчас в множестве», и Set (или массив флагов) «число в множестве».
- **Инициализация:** heap = [1, 2, …, 1000], inSet = все true для 1..1000.
- **popSmallest:** извлечь минимум из кучи, пометить inSet[num] = false, вернуть num.
- **addBack(num):** если inSet[num] — не делать ничего; иначе inSet[num] = true, положить num в кучу.
- **Сложность:** pop и addBack — O(log n), n ≤ 1000; память O(1000).
- **Плюсы:** единая структура (куча), предсказуемая сложность; минус — жёстко завязано на ограничение задачи.

---

## Альтернатива 3: Массив + указатель (при ограничении 1000)

- **Идея:** `present[1..1000]` — число в множестве или нет; `next` — кандидат на следующий минимум из «бесконечного хвоста». Минимум в любой момент — либо кто‑то из добавленных обратно (и меньше `next`), либо `next`.
- Чтобы не сканировать массив каждый раз, «добавленные обратно» удобно хранить в min-heap или отсортированной структуре. Тогда по сути получается гибрид с альтернативой 1 или 2.
- **Чисто массив без кучи:** при каждом pop перебирать от 1 до 1000 и искать первый `present[i] === true` — O(1000) на pop; addBack — O(1). Реализуемо, но при 1000 вызовах хуже по времени, чем куча.

---

## Сводка

| Подход              | popSmallest | addBack | Память | Зависимость от ограничения 1000 |
|---------------------|-------------|---------|--------|----------------------------------|
| Set + счётчик       | O(k)        | O(1)    | O(k)   | Нет                              |
| Heap для addBack + счётчик | O(log k) | O(log k) | O(k) | Нет                      |
| Одна куча 1..1000   | O(log n)    | O(log n)| O(n)   | Да                               |
| Массив + линейный поиск | O(1000) | O(1)  | O(1000)| Да                               |

**Основной вариант** в конспекте — Set + счётчик: простой и без ограничения на верхнюю границу. **Альтернативы** — min-heap для ускорения (для addBack или одна куча на 1..1000) и вариант с массивом при жёстком ограничении задачи.
