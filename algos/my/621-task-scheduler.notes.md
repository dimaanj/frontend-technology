# 621. Task Scheduler — итоги разбора

## Условие (кратко)

Между любыми двумя выполнениями одной и той же задачи должно пройти не менее n единиц времени. Вернуть минимальное число тактов для выполнения всех задач.

## Решение (heap + deque)

- Heap (max по остатку, через MinHeap с отрицательными значениями): всегда берём задачу с максимальным оставшимся количеством.
- Deque: пары `{ count, readyTime }` — задача снова доступна с такта `readyTime = time + n + 1`.
- В начале каждого такта: вернуть в heap всё из deque с `readyTime <= time`, затем выполнить одну задачу из heap (если есть) и при остатке положить в deque с `readyTime = time + n + 1`.

Почему `time + n + 1`: слоты «между» двумя выполнениями — это ровно n штук (time+1 … time+n), следующий разрешённый такт — time + n + 1.

## Сложность

- **Время:** O(T), где T — ответ (число тактов). Зависит от результата, не только от длины массива.
- **Память:** O(k) для map и heap, плюс deque; k — число типов задач.

## Альтернатива — формула

Подсчёт частот → maxCount, numWithMax (сколько типов с такой частотой).  
`frame = (maxCount - 1) * (n + 1) + numWithMax`, ответ = `max(tasks.length, frame)`.  
Время O(n), память O(k). Удобно, когда нужен только ответ без построения расписания.

## Краевые случаи

- Пустой массив → 0.
- Одна задача → 1 при любом n.
- n = 0 → ответ равен длине массива (можно выполнять подряд).
- Один тип задач (например, три A, n = 2) → 7: A → idle → idle → A → idle → idle → A.

## Почему порядок в цикле важен

Сначала возврат из deque в heap, потом выполнение. Иначе в такт t задача с readyTime = t не попала бы в heap в этой итерации и такт считался бы idle — ответ завысился бы.

## Почему heap по максимуму остатка

Выбор задачи с минимальным остатком привёл бы к быстрому исчерпанию «разнообразия» и лишним idle — общее время выросло бы.
