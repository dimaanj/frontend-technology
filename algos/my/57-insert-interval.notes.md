# 57. Insert Interval — итоги разбора

## Условие (кратко)

Массив интервалов `intervals` отсортирован по `start_i`. Дан ещё интервал `newInterval`. Вставить его в массив так, чтобы порядок по началу сохранился и перекрывающиеся интервалы были объединены. Вернуть итоговый массив.

## Решение

Один проход по `intervals` с тремя случаями на каждом шаге:

1. **newInterval строго до current** (`newInterval[1] < current[0]`): newInterval ни с кем не пересекается, вставляем его «между» — возвращаем `[...res, newInterval, current, ...intervals.slice(i + 1)]` и выходим.
2. **newInterval строго после current** (`newInterval[0] > current[1]`): текущий интервал не пересекается с новым — пушим `current` в `res`, идём дальше.
3. **Пересечение**: мержим в один интервал `[min(current[0], newInterval[0]), max(current[1], newInterval[1])]`, записываем в `newInterval` и продолжаем (следующий интервал может тоже пересекаться с уже слитым).

После цикла в `res` пушится итоговый (возможно слитый) `newInterval` — случай, когда он в конце или когда все перекрывающиеся уже смержены.

Пустой `intervals`: по текущей реализации делается `intervals.push(newInterval)` и дальше цикл отрабатывает; корректнее без мутации входа: `return [newInterval]`.

## Сложность

- **Время:** O(n) — один проход; в ветке раннего return — `slice` O(n), в сумме не хуже O(n).
- **Память:** O(n) на массив результата; при раннем return создаётся копия через spread/slice.

## Альтернативы

- **Три фазы с индексом:** сначала пушить все «до» newInterval, затем один раз посчитать слитый интервал (подтягивая все пересекающиеся), один раз его пушить, затем пушить «после». Та же асимптотика, чуть более явная структура.
- **Вставка + merge:** добавить newInterval в массив, отсортировать по start и прогнать merge как в задаче 56. Время O(n log n), код проще, но хуже по времени при уже отсортированном вводе.

## Что поправляли при ревью

- Условие пересечения: при слиянии учитывать **начало** слитого интервала — `min(current[0], newInterval[0])`, иначе при впритык слева ([1,2] и [2,5]) получалось [2,5] вместо [1,5].
- В фазе перекрытия: пушить **один** слитый интервал после того, как подтянуты все подряд пересекающиеся, а не пушить каждый current по отдельности.
- Вставка newInterval, когда он ни с кем не пересекается: явно добавлять его в результат (до всех, между или после) — в текущем решении это ветка «newInterval строго до current» и финальный `res.push(newInterval)`.
- Ранний return: возвращать полный результат — `[...res, newInterval, current, ...intervals.slice(i + 1)]`, а не `[newInterval, ...current]` (spread `current` давал бы элементы интервала по отдельности, плюс терялись бы накопленный `res` и хвост массива).

## Краевые случаи

- Пустой `intervals` → `[newInterval]`.
- Один интервал: новый до / после / перекрытие / расширение влево-вправо.
- Новый в начале или в конце без пересечения.
- Новый между двумя без пересечения.
- Новый перекрывает несколько подряд → один слитый интервал.
- Новый покрывает все интервалы → один интервал.
- Впритык слева/справа (границы впритык считаются перекрытием).
- Интервал-точка `[5,5]` между двумя.
